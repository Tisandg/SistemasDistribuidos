/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "interfaz.h"
#include <dirent.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <string.h>
#define FALSO 0
#define VERDAD 1

FILE * usuarios=NULL;
proxNodo cabeza=NULL,sigUsuario;
fichas Todas_Fichas;
fichas Validas_Fichas;
fichas Servidor_fichas;
fichas Cliente_Fichas;
fichas Tablero;
ficha Nueva_Ficha;
int vector_aux[28];
int lados_validos[2];
int tam_tablero=0;
int tam_servidor=0;
int tam_cliente=0;
int jugadas = 0;

void Llenar_Todas_Fichas();
void Llenar_Validas_Fichas(int);
ficha* buscar_Ficha(int);
void dividir(fichas, int);
ficha* buscar_Ficha_v2(fichas, int, int, int);
ficha* buscar_Ficha_v3(fichas , int, int);
int Actualizar_Tablero(ficha*);
void lados_Tablero();
ficha* Jugada_Servidor();
void Imprimir_Fichas(fichas, int);


bool_t *
autenticar_usuario_1_svc(datosValidar *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = FALSE;
	int permisos = argp->permiso;
	DIR *dir;

	if(permisos==0){

		printf("\nBuscando Administrador %d...",argp->login);
	    proxNodo nuevoUsuario;
		dir = opendir ("Administrador");
	    /* Miramos que no haya error */
		if (dir == NULL)
		error("No puedo abrir el directorio");	 
		/* Una vez nos aseguramos de que no hay error, se procede a  */
		/* leer uno a uno todos los archivos que hay */

		char path[100]="./Administrador/admin.txt";
		FILE * usuarioarchivo = fopen(path,"r");
		nodo_usuario temp;
		fread(&temp,sizeof(nodo_usuario),1,usuarioarchivo);
		nuevoUsuario = &temp;
		if(nuevoUsuario->login == argp->login &&  strncmp(nuevoUsuario->contrasena,argp->contrasena,10)==0){
			printf("Administrador Encontrado\n");
			result = TRUE;
		}else{
			printf("Administrador No Encontrado\n");
			result = FALSE;
		}

	}else{
		printf("\nBuscando Usuario %d...",argp->login);
		DIR *dir;
		/* en *ent habrá información sobre el archivo que se está "sacando" a cada momento */
		struct dirent *ent;
    	proxNodo nuevoUsuario;

		dir = opendir ("Usuarios");
    	/* Miramos que no haya error */
		if (dir == NULL)
		error("No puedo abrir el directorio");
		 
		/* Una vez nos aseguramos de que no hay error, se procede a  */
		/* leer uno a uno todos los archivos que hay */
	
		if (dir!=NULL){
			while ((ent = readdir (dir)) != NULL){
				if ( (strcmp(ent->d_name, ".")!=0) && (strcmp(ent->d_name, "..")!=0) ){
					char path[100]="./Usuarios/";
					nodo_usuario temp;
					strcat(path,ent->d_name);
					FILE * usuarioarchivo = fopen(path,"r");
					fflush(stdout);
					fread(&temp,sizeof(nodo_usuario),1,usuarioarchivo);
					nuevoUsuario = &temp;
					if(nuevoUsuario->login == argp->login &&  strncmp(nuevoUsuario->contrasena,argp->contrasena,10)==0){
						printf("Usuario Encontrado\n");
						Llenar_Todas_Fichas();
						result = TRUE;
						return &result;
					}
				}
			
			}
		}
	
		printf("Usuario NO Encontrado....\n");
		result = FALSE;
		return &result;
			/*------------------------------------------*/
	}
	return &result;
}

bool_t *
registrarusuario_1_svc(proxNodo *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("\n Creando nuevo Usuario. \n");
	fflush(stdout);
	nodo_usuario Nuevo_Usuario;
	printf("%s",(*argp)->nombres);
	fflush(stdout);
	strcpy(Nuevo_Usuario.nombres,(*argp)->nombres);
	strcpy(Nuevo_Usuario.apellidos,(*argp)->apellidos);
	Nuevo_Usuario.login = (*argp)->login;
	strcpy(Nuevo_Usuario.contrasena,(*argp)->contrasena);
	Nuevo_Usuario.permiso = (*argp)->permiso;
	Nuevo_Usuario.nodoSiguiente = NULL;

	char archivo[1000] = "./Usuarios/usuario_";
	/*Pasar  login a cadena*/
	char numero[100];
	sprintf(numero, "%d", (*argp)->login);
	strcat(archivo,numero);
	strcat(archivo,".txt");
	usuarios = fopen(archivo,"a+b");
	if(usuarios!=NULL){
		fwrite(&Nuevo_Usuario,sizeof(nodo_usuario),1,usuarios);
		fclose(usuarios);
		result = TRUE;
	}
	else{
		printf("\n Error al abrir el archivo");
		result = FALSE;	
	}
	printf("\n Registro creado correctamente");
	fflush(stdout);

	return &result;
}

proxNodo *
listarusuarios_1_svc(void *argp, struct svc_req *rqstp)
{
	static proxNodo  result;
	
	free (cabeza);
	printf("\nListando usuarios...\n");
	/* Con un puntero a DIR abriremos el directorio */
	DIR *dir;
	/* en *ent habrá información sobre el archivo que se está "sacando" a cada momento */
	struct dirent *ent;
    proxNodo nuevoUsuario;
	char bufer [sizeof(nodo_usuario)] ;
	dir = opendir ("Usuarios");

	/* Miramos que no haya error */
	if (dir == NULL)
		error("No puedo abrir el directorio");
		 
	/* Una vez nos aseguramos de que no hay error, se procede a  */
	/* leer uno a uno todos los archivos que hay */

	if (dir!=NULL){
			nodo_usuario temp;
		    while ((ent = readdir (dir)) != NULL){
				if ( (strcmp(ent->d_name, ".")!=0) && (strcmp(ent->d_name, "..")!=0) ){
					char path[1000]="./Usuarios/";
					strcat(path,ent->d_name);
					printf("%s \n",path);
					FILE * usuarioarchivo = fopen(path,"r");
					fread(&temp,sizeof(nodo_usuario),1,usuarioarchivo);
					nuevoUsuario = (proxNodo) malloc(sizeof(nodo_usuario));
					strcpy(nuevoUsuario->nombres,temp.nombres);
					strcpy(nuevoUsuario->apellidos,temp.apellidos);
					nuevoUsuario->login = temp.login;
					strcpy(nuevoUsuario->contrasena,temp.contrasena);
					nuevoUsuario->permiso = temp.permiso;
					
					if(cabeza==NULL){
						cabeza = nuevoUsuario;
						sigUsuario = cabeza;
					}else{
						sigUsuario->nodoSiguiente=nuevoUsuario;
						sigUsuario=nuevoUsuario;
					}
					printf("Login: %d\n\n",nuevoUsuario->login);
					sigUsuario->nodoSiguiente=NULL;
					fclose(usuarioarchivo); 
			    }
			}
	}
	closedir (dir);
	result = cabeza;
	printf("\nUsuarios listados correctamente...\n");

	return &result;
}

bool_t *
eliminar_usuario_1_svc(datosValidar *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	DIR *dir;
	/* en *ent habrá información sobre el archivo que se está "sacando" a cada momento */
	struct dirent *ent;
	proxNodo nuevoUsuario;

	dir = opendir ("Usuarios");
	/* Miramos que no haya error */
	if (dir == NULL)
	error("No puedo abrir el directorio");
	 
	/* Una vez nos aseguramos de que no hay error, se procede a  */
	/* leer uno a uno todos los archivos que hay */

	if (dir!=NULL){
		while ((ent = readdir (dir)) != NULL){
			if ( (strcmp(ent->d_name, ".")!=0) && (strcmp(ent->d_name, "..")!=0) ){
				char path[100]="./Usuarios/";
				nodo_usuario temp;
				strcat(path,ent->d_name);
				FILE * usuarioarchivo = fopen(path,"r");
				fflush(stdout);
				fread(&temp,sizeof(nodo_usuario),1,usuarioarchivo);
				nuevoUsuario = &temp;
				if(nuevoUsuario->login == argp->login ){ //encontro el archivo
					if(remove(path)==0){
						printf("El archivo del usuario a sido eliminado");
						result = TRUE;
					}else{
						return FALSE;			
					}
				}
			}
		
		}
	}

	return &result;
}

bool_t *
modificar_usuario_1_svc(proxNodo *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	/*
	 * insert server code here
	 */
	return &result;
}

nodo_usuario *
consultarusuario_1_svc(datosValidar *argp, struct svc_req *rqstp)
{
	static nodo_usuario result;

	DIR *dir;
	printf("Buscando usuario %d...\n",argp->login);
	/* en *ent habrá información sobre el archivo que se está "sacando" a cada momento */
	struct dirent *ent;
    proxNodo nuevoUsuario;

	dir = opendir ("Usuarios");
    /* Miramos que no haya error */
	if (dir == NULL)
	error("No puedo abrir el directorio");
		 
	/* Una vez nos aseguramos de que no hay error, se procede a  */
	/* leer uno a uno todos los archivos que hay */
	
	if (dir!=NULL){
		while ((ent = readdir (dir)) != NULL){
			if ( (strcmp(ent->d_name, ".")!=0) && (strcmp(ent->d_name, "..")!=0) ){
				char path[1000]="./Usuarios/";
				nodo_usuario temp;
				strcat(path,ent->d_name);
				FILE * usuarioarchivo = fopen(path,"r");
				fflush(stdout);
				fread(&temp,sizeof(nodo_usuario),1,usuarioarchivo);
				nuevoUsuario = &temp;
				if(nuevoUsuario->login == argp->login &&  strncmp(nuevoUsuario->contrasena,argp->contrasena,30)==0){
					strcpy(result.nombres,nuevoUsuario->nombres);
					strcpy(result.apellidos,nuevoUsuario->apellidos);
					result.login = nuevoUsuario->login;
					strcpy(result.contrasena,nuevoUsuario->contrasena);
					result.permiso = nuevoUsuario->permiso;
					printf("\n Usuario Encontrado\n");

					return &result;
				}
			}
			
		}
	}
	printf("Usuario NO Encontrado....\n");
	return &result;
}

fichas *
repartir_fichas_1_svc(int *argp, struct svc_req *rqstp)
{
	int tam = (*argp);
	printf("\nEl servidor esta repartiendo las %d fichas...\n", tam);

	if(tam!=28){
		Llenar_Validas_Fichas(tam);
		dividir(Validas_Fichas, tam);
	}else{
		dividir(Todas_Fichas, tam);
	}
	printf("\nSe han repartido las fichas.\n");
	Imprimir_Fichas(Servidor_fichas, tam_servidor);
	return &Cliente_Fichas;
}

fichas *
empezar_partida_1_svc(void *argp, struct svc_req *rqstp)
{
	static fichas aux_tablero;
	ficha *Nueva_Ficha;
	printf("Tamaño vector Servidor_fichas :%d\n",tam_servidor);
	Nueva_Ficha = buscar_Ficha_v3(Servidor_fichas, 28, tam_servidor);
	printf("\nEMPIEZA EL JUEGO\n");
	if(Nueva_Ficha == (ficha *) NULL){
		printf("\nInicia el Usuario...\n");
		aux_tablero.fichasJugadores[0].id = -1;
		jugadas++;
		return &aux_tablero;
	}else{
		printf("\nInicia el Servidor...\n");
		Tablero.fichasJugadores[0].lado_A = (*Nueva_Ficha).lado_A;
		Tablero.fichasJugadores[0].lado_B = (*Nueva_Ficha).lado_B;
		Tablero.fichasJugadores[0].id = (*Nueva_Ficha).id;
		tam_tablero++;
		return &Tablero;
	}
}

fichas *
enviar_jugada_1_svc(int *argp, struct svc_req *rqstp)
{
	int id_Ficha = (*argp);
	int repintar;
	static ficha Nueva_Ficha;
	static ficha Nueva_Ficha_Servidor;
	printf("resiviendo uan jugada del usuario.....\n");

	if (id_Ficha == -1){
		printf("El usuario pasa......\n");
		printf("El servidor esta pensando su jugada....\n");
		Nueva_Ficha_Servidor = (*Jugada_Servidor());

		if (Nueva_Ficha_Servidor.id == -1){
				printf("El servidor pasa .....\n");
				return NULL;
		}else{
			repintar = Actualizar_Tablero(&Nueva_Ficha_Servidor);
			if (repintar == VERDAD){
				printf("Ficha del servidor colocada en el Tablero...\n");
				return &Tablero;
			}else{
				error("Error al colocar la ficha del Servidor en el Tablero...");		
			}
		}

		return NULL;

	}else{

		Nueva_Ficha = (*buscar_Ficha(id_Ficha));  //Funcion
		printf("Ficha[%d]	lado_A=%d 	lado_B=%d \n",Nueva_Ficha.id, Nueva_Ficha.lado_A, Nueva_Ficha.lado_B);
		//Encargada de colocar la ficha en el arreglo Tablero, retorna un entero.
		repintar = Actualizar_Tablero(&Nueva_Ficha);
		
		if (repintar == VERDAD){
			printf("Ficha del usuario colocada en el Tablero...\n");
			tam_tablero++;
			printf("El servidor esta pensando su jugada....\n");
			Nueva_Ficha_Servidor = (*Jugada_Servidor());
			printf("Ficha[%d]	lado_A=%d 	lado_B=%d \n",Nueva_Ficha_Servidor.id, Nueva_Ficha_Servidor.lado_A, Nueva_Ficha_Servidor.lado_B);

			if (Nueva_Ficha_Servidor.id == -1){
				printf("El servidor pasa .....\n");
				return NULL;
			}else{
				repintar = Actualizar_Tablero(&Nueva_Ficha_Servidor);
				if (repintar == VERDAD){
					printf("Ficha del servidor colocada en el Tablero...\n");
					tam_tablero++;
					return &Tablero;
				}else{
					error("Error al colocar la ficha del Servidor en el Tablero...");		
				}
			}

		}else{
			error("Error al colocar la ficha del usuario en el Tablero...");
		}	
	}	

	return &Tablero;
}

fichas *
estado_tablero_1_svc(void *argp, struct svc_req *rqstp)
{
	return &Tablero;
}

fichas *
estado_cliente_1_svc(void *argp, struct svc_req *rqstp)
{
	return &Servidor_fichas;
}

int *
contar_puntos_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
consultar_estadisticas_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
salir_1_svc(void *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}

/*Las Funciones Locales que utilizare*/
//Llena el vector de estructuras con todas las fichas validas del juego
void Llenar_Todas_Fichas(){
	int pos = 0, k = 0, p = 0;
	for(k=0; k<7; k++){
		for(p=k; p<7; p++){
			Todas_Fichas.fichasJugadores[pos].lado_A=k;
			Todas_Fichas.fichasJugadores[pos].lado_B=p;
			Todas_Fichas.fichasJugadores[pos].id=(pos+1);
			pos++;
			}
		}
}

/*Llenamos el vector que contrendra el numero de fichas con las que se jugara*/
void Llenar_Validas_Fichas(int tam){
	srand(time(NULL));
	int i=0, j=0;
	//memset(vector_aux,-1,28);

	//vector aux para guardar al azar los id de las fichas jugar	
	for(j = 0; j < 28 ; j++){
		vector_aux[j]= -1;
	}
	vector_aux[i] = 28;
	i++;

	while(i<tam){
		int randon = rand()%28 + 1;
		if(existe2(vector_aux, randon, i) == FALSO){//si no existe lo agregamos al vector
			//printf("entro randonm");
			vector_aux[i] = randon;
			i++;
		}			 
	}
	printf("Aleatorios generados\n");
	for(j = 0; j < tam ; j++){
		printf("%d | ",vector_aux[j]);
	}
	i=0;
	while(i < tam){
		ficha *Nueva_Ficha;
		Nueva_Ficha = buscar_Ficha((vector_aux[i]-1));
		printf("Ficha [%d] = %d|%d\n",(*Nueva_Ficha).id,(*Nueva_Ficha).lado_A,(*Nueva_Ficha).lado_B);
		Validas_Fichas.fichasJugadores[i].lado_A = (*Nueva_Ficha).lado_A;
		Validas_Fichas.fichasJugadores[i].lado_B = (*Nueva_Ficha).lado_B;
		Validas_Fichas.fichasJugadores[i].id = (*Nueva_Ficha).id;
		i++;
	}
	printf("Se han seleccionado las fichas para los juegos...\n\n");
}

ficha* Jugada_Servidor(){
	static ficha Nueva_Ficha;
	Nueva_Ficha.id = -1;
	lados_Tablero();
	printf("Tamaño Servidor..%d \n",tam_servidor );
	printf("Lado valido_A = %d Lado valido_B = %d\n", lados_validos[0],lados_validos[1]);

	int i = 0;
	while(i < tam_servidor){
		if ((Servidor_fichas.fichasJugadores[i].id != -1) && (Servidor_fichas.fichasJugadores[i].lado_A == lados_validos[0] || 
			Servidor_fichas.fichasJugadores[i].lado_B == lados_validos[0] || Servidor_fichas.fichasJugadores[i].lado_A == lados_validos[1] || 
			Servidor_fichas.fichasJugadores[i].lado_B == lados_validos[1])){
			
			Nueva_Ficha.lado_A = Servidor_fichas.fichasJugadores[i].lado_A;
			Nueva_Ficha.lado_B = Servidor_fichas.fichasJugadores[i].lado_B;
			Nueva_Ficha.id = Servidor_fichas.fichasJugadores[i].id;

			Servidor_fichas.fichasJugadores[i].id = -1;

			return &Nueva_Ficha;
		}

		i++;
	}

	return &Nueva_Ficha;
}

ficha* buscar_Ficha(int id_Ficha){

	Nueva_Ficha.lado_A = Todas_Fichas.fichasJugadores[id_Ficha].lado_A;
	Nueva_Ficha.lado_B = Todas_Fichas.fichasJugadores[id_Ficha].lado_B;
	Nueva_Ficha.id = Todas_Fichas.fichasJugadores[id_Ficha].id;
	
	return &Nueva_Ficha;
}

/*Busca una ficha deacuerdo a los lados de la misma*/
ficha* buscar_Ficha_v2(fichas vector_aux, int lad_A, int lad_B, int tam){
	static ficha Nueva_Ficha;

	return &Nueva_Ficha;
}

/*Busca una ficha deacuerdo al id de la misma*/
ficha* buscar_Ficha_v3(fichas vector_aux, int id_Ficha, int tam){
	static ficha Nueva_Ficha;
	int i=0;
	while(i<tam){
		if ((vector_aux.fichasJugadores[i].id == id_Ficha)){
			Nueva_Ficha.lado_A = vector_aux.fichasJugadores[i].lado_A;
			Nueva_Ficha.lado_B = vector_aux.fichasJugadores[i].lado_B;
			Nueva_Ficha.id = vector_aux.fichasJugadores[i].id;
			return &Nueva_Ficha;
		}
		i++;
	}
	return NULL;
}

int existe(int vector[], int numero, int tam){
	int i = 0;

	while(i < tam){
		if(vector[i] == numero){
			return FALSO;
		}
		i++;
	}
	return VERDAD;
} 
int existe2(int vector[], int numero, int tam){
	int i = 0;
	for(i =0 ;i < tam ;i++ ){
		if(vector[i] == numero){
			return VERDAD;
		}
	}
	return FALSO;
}

void dividir(fichas obj_fichas, int tam){

	printf("Empezamos a repartir las %d Piezas....\n",tam );
	srand(time(NULL));
	int v_aux1[tam/2];
	int v_aux2[tam/2];
	int v_aux_usadas[tam];
	int i=0, j=0, k=0;
	memset(v_aux_usadas,-1,tam);

	while(i<tam){
		//Escogemos al azar un numero entre 1 y el tamaño escogido
		int randon = rand()%tam + 1;

		//verificamos que las fichas no han sido utilizadas
		if(existe(v_aux_usadas, randon, i) != FALSO){ //falso si se encuentra
			if((i%2)==0){
				v_aux1[j] = randon;
				j++;
			}else{
				v_aux2[k] = randon;
				k++;
			}
			v_aux_usadas[i] = randon;
			i++;
		}
	}

	i=0;
	printf("Llenando Cliente_Fichas...\n");
	while(i < j){
		int indice = v_aux1[i] -1;//al no hacer esto imprimia el cero. el indice 28 se desbordaba y generaba el 0
		Cliente_Fichas.fichasJugadores[i].lado_A = Validas_Fichas.fichasJugadores[indice].lado_A;
		Cliente_Fichas.fichasJugadores[i].lado_B = Validas_Fichas.fichasJugadores[indice].lado_B;
		Cliente_Fichas.fichasJugadores[i].id = Validas_Fichas.fichasJugadores[indice].id;
		printf("ficha [%d] \n", Cliente_Fichas.fichasJugadores[i].id);
		i++;
	}
	i = 0;
	printf("Llenando Servidor_fichas..\n");
	while(i < k){
		int indice = v_aux2[i] -1;
		Servidor_fichas.fichasJugadores[i].lado_A = Validas_Fichas.fichasJugadores[indice].lado_A;
		Servidor_fichas.fichasJugadores[i].lado_B = Validas_Fichas.fichasJugadores[indice].lado_B;
		Servidor_fichas.fichasJugadores[i].id = Validas_Fichas.fichasJugadores[indice].id;
		printf("ficha [%d] \n", Servidor_fichas.fichasJugadores[i].id);
		i++;
	}
	tam_cliente = j;
	tam_servidor = k;
}

int tam_Vector(fichas vector){
	int tam = 0;
	while(((vector.fichasJugadores[tam].id == '\0') && (vector.fichasJugadores[tam].lado_A == '\0') && (vector.fichasJugadores[tam].lado_B == '\0'))
		|| ((vector.fichasJugadores[tam].id != '\0') && (vector.fichasJugadores[tam].lado_A != '\0') && (vector.fichasJugadores[tam].lado_B != '\0')))
		tam++;
	return tam;
}

/*Funcion encargada de colocar una nueva ficha en el tablero*/
/*retorna un entero*/
int Actualizar_Tablero(ficha *Nueva_Ficha){
	lados_Tablero(); //Llamado a funcion que ctualiza los posibles valores que puede recibir el tablero
	fichas aux_tablero;
	printf("Colocando la ficha en el Tablero...\n");
	printf("Tamaño Tablero...%d \n",tam_tablero);
	int i = 0;
	if(lados_validos[0]!=-1 && lados_validos[1]!=-1){
		if(lados_validos[1] == (*Nueva_Ficha).lado_A || lados_validos[1] == (*Nueva_Ficha).lado_B){
			//Se inserta la ficha en el lado derecho
			Tablero.fichasJugadores[tam_tablero].lado_A = (*Nueva_Ficha).lado_A;
			Tablero.fichasJugadores[tam_tablero].lado_B = (*Nueva_Ficha).lado_B;
			Tablero.fichasJugadores[tam_tablero].id = (*Nueva_Ficha).id;
			return VERDAD;

		}else{
			if (lados_validos[0] == (*Nueva_Ficha).lado_A || lados_validos[0] == (*Nueva_Ficha).lado_B){
				//Se inserta la ficha en el lado izquierdo
				for (i = 0; i < tam_tablero; i++){
					aux_tablero.fichasJugadores[i].lado_A = Tablero.fichasJugadores[i].lado_A;
					aux_tablero.fichasJugadores[i].lado_B = Tablero.fichasJugadores[i].lado_B;
					aux_tablero.fichasJugadores[i].id = Tablero.fichasJugadores[i].id;
				}
				Tablero.fichasJugadores[0].lado_A = (*Nueva_Ficha).lado_A;
				Tablero.fichasJugadores[0].lado_B = (*Nueva_Ficha).lado_B;
				Tablero.fichasJugadores[0].id = (*Nueva_Ficha).id;
				
				for (i = 0; i < tam_tablero; i++){
					Tablero.fichasJugadores[i+1].lado_A = aux_tablero.fichasJugadores[i].lado_A;
					Tablero.fichasJugadores[i+1].lado_B = aux_tablero.fichasJugadores[i].lado_B;
					Tablero.fichasJugadores[i+1].id = aux_tablero.fichasJugadores[i].id;
				}
				return VERDAD;
			}else{
				return FALSO;
			}
		}
	}else{
		Tablero.fichasJugadores[0].lado_A = (*Nueva_Ficha).lado_A;;
		Tablero.fichasJugadores[0].lado_B = (*Nueva_Ficha).lado_B;
		Tablero.fichasJugadores[0].id = (*Nueva_Ficha).id;
		return VERDAD;
	}
	

	return FALSO;
}


void lados_Tablero(){
	int i=0;
	int izq, der, aux_izq, aux_der;

	if(tam_tablero > 0){
		while(i < tam_tablero){
			if(i==0){
				izq = 6,
				der = 6;
			}else{
				aux_izq = Tablero.fichasJugadores[i].lado_A;
				aux_der = Tablero.fichasJugadores[i].lado_B;

				if(der == aux_der)
					der = aux_izq;
				else
					if(der == aux_izq)
						der = aux_der;
					else
						if (izq == aux_izq)
							izq = aux_der;
						else
							if(izq == aux_der)
								izq = aux_izq;
			}
			i++;
		}
	lados_validos[0] = izq;
	lados_validos[1] = der;
	
	}else{
		lados_validos[0] = -1;
		lados_validos[1] = -1;	
	}

	

}

void Imprimir_Fichas(fichas Fichas_Imprimibles, int tam){
	int i = 0;
	while(i < tam){
		printf("Ficha[%d]	lado_A = %d   |   Lado_B = %d\n", Fichas_Imprimibles.fichasJugadores[i].id, 
			Fichas_Imprimibles.fichasJugadores[i].lado_A, Fichas_Imprimibles.fichasJugadores[i].lado_B);
		i++;
	}

}
//	|4|6|--|6|6|--|6|5|--		|4|5|
